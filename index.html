<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="utf-8">
<title>River & Cell Shading + Clickable Objects + Lerp Camera</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  html, body { height:100%; margin:0; overflow:hidden; background:#000; color:white; font-family:monospace; }
  #camInfo {
    position:fixed; top:10px; left:10px;
    background: rgba(0,0,0,0.6); padding:10px; border-radius:8px;
    font-size:13px; line-height:1.5; z-index:10;
  }
</style>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
</head>
<body>
<div id="camInfo">Loading camera info...</div>
<script>
// ==================== Shader ====================
const vert = `
varying vec3 vNormal;
varying vec3 vPosW;
void main(){
  vNormal = normalize(mat3(modelMatrix) * normal);
  vPosW = (modelMatrix * vec4(position, 1.0)).xyz;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
}`;
const frag = `
precision mediump float;
varying vec3 vNormal;
varying vec3 vPosW;
uniform vec3 uLightDir;
void main(){
  float diffuse = max(dot(vNormal,uLightDir),0.0);
  float levels = 4.0;
  diffuse = floor(diffuse*levels)/levels;
  diffuse += 0.6;
  vec3 R = reflect(-uLightDir,vNormal);
  vec3 V = normalize(cameraPosition - vPosW);
  float specular = clamp(pow(dot(R,V),4.0),0.0,1.0);
  specular = smoothstep(0.4,0.6,specular);
  if(diffuse <= 0.5) specular = 0.0;
  vec3 baseColor = vec3(1.0,0.5,0.0);
  vec3 color = (baseColor*diffuse) + vec3(specular);
  gl_FragColor = vec4(color,1.0);
}`;

// ==================== Scene & HDR ====================
const scene = new THREE.Scene();
new THREE.RGBELoader().load(
  "https://natthawadee-jansamut.github.io/Model_Final/syferfontein_1d_clear_puresky_1k.hdr",
  tex => {
    tex.mapping = THREE.EquirectangularReflectionMapping;
    scene.background = tex;
    scene.environment = tex;
  }
);

// ==================== Camera & Renderer ====================
const camera = new THREE.PerspectiveCamera(95, innerWidth/innerHeight, 0.1, 200);
camera.position.set(65.4,63.23,0);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// ==================== Controls ====================
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// ==================== Lights ====================
const ambientLight = new THREE.AmbientLight(0xffffff,0.5);
scene.add(ambientLight);
const dirLight = new THREE.DirectionalLight(0xffffff,0.6);
dirLight.position.set(25,60,25);
dirLight.castShadow = true;
dirLight.shadow.mapSize.width = dirLight.shadow.mapSize.height = 4096;
dirLight.shadow.camera.near=1; dirLight.shadow.camera.far=150;
dirLight.shadow.camera.left=-80; dirLight.shadow.camera.right=80;
dirLight.shadow.camera.top=80; dirLight.shadow.camera.bottom=-80;
scene.add(dirLight);

// ==================== Ground ====================
const ground = new THREE.Mesh(new THREE.PlaneBufferGeometry(100,100), new THREE.MeshStandardMaterial({color:0x222222, roughness:1}));
ground.rotation.x=-Math.PI/2;
ground.position.y=-1;
ground.receiveShadow = true;
scene.add(ground);

// ==================== Load GLB ====================
const loader = new THREE.GLTFLoader();
const draco = new THREE.DRACOLoader();
draco.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
loader.setDRACOLoader(draco);

let riverMesh = null;
const clickable = [];
const TARGET_NAMES = ['Plane','KU'];

loader.load('https://natthawadee-jansamut.github.io/Model_Final/FINAL_1.glb', gltf => {
  const model = gltf.scene;
  model.traverse(n=>{
    if(n.isMesh){
      n.castShadow = n.receiveShadow = true;
      const lname = n.name.toLowerCase();

      // Plane หมุน
      if(lname === "plane"){ n.rotation.x=-Math.PI; n.rotation.y=Math.PI; }

      // Object_183 Cell shading
      if(lname==="object_183"){
        n.material = new THREE.ShaderMaterial({
          vertexShader: vert,
          fragmentShader: frag,
          uniforms:{ uLightDir:{value:new THREE.Vector3(0.5,1,0.5).normalize()} },
          side: THREE.DoubleSide
        });
      }

      // River shader
      if(lname.includes("river")){
        n.scale.set(1.05,1.05,1.05); n.position.y+=0.1;
        const vertShader = `
uniform float uTime;
varying vec3 vNormal;
void main(){
  vNormal = normalize(normalMatrix*normal);
  vec3 pos = position;
  pos.y += sin(pos.x*0.4 + uTime*2.0)*0.15;
  pos.y += cos(pos.z*0.3 + uTime*1.5)*0.1;
  pos.y += sin(uTime*0.5)*0.05;
  gl_Position = projectionMatrix*modelViewMatrix*vec4(pos,1.0);
}`;
        const fragShader = `
varying vec3 vNormal;
void main(){
  vec3 waterColor = vec3(0.6,0.8,1.0);
  gl_FragColor = vec4(waterColor,0.4);
}`;
        n.material = new THREE.ShaderMaterial({
          vertexShader: vertShader,
          fragmentShader: fragShader,
          uniforms:{ uTime:{value:0} },
          transparent:true, depthWrite:false, side:THREE.DoubleSide
        });
        riverMesh = n;
      }

      // Clickable objects
      if(TARGET_NAMES.includes(n.name)) clickable.push(n);
    }
  });
  scene.add(model);
});

// ==================== Camera views ====================
const VIEWS = {
  Plane: { pos: new THREE.Vector3(10,50,22), tar:new THREE.Vector3(0,0,0) },
  KU: { pos: new THREE.Vector3(66,18,10), tar:new THREE.Vector3(0,0,0) },
};

// ==================== Raycaster ====================
const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();
let targetPos=null, targetTar=null, lerpProgress=0;
const lerpSpeed=0.05;

function setPointer(e){
  const r = renderer.domElement.getBoundingClientRect();
  pointer.x = ((e.clientX ?? e.touches[0].clientX)-r.left)/r.width*2-1;
  pointer.y = -(((e.clientY ?? e.touches[0].clientY)-r.top)/r.height*2-1);
}

// --- Raycaster + Clickable + Lerp Camera ---
function onPick(e){
  setPointer(e);
  raycaster.setFromCamera(pointer,camera);
  const hit = raycaster.intersectObjects(clickable,false)[0];
  if(!hit) return;

  // ใช้ตำแหน่งวัตถุจริงเป็น target
  const objPos = hit.object.position.clone();

  // กำหนด view ใหม่: tar = วัตถุ, pos = offset กล้องจากวัตถุ
  const offset = new THREE.Vector3(30, 2, 0); // 
  targetPos = objPos.clone().add(offset); // กล้องอยู่ห่างจากวัตถุ
  targetTar = objPos.clone(); // กล้องมองตรงไปที่วัตถุ
  lerpProgress = 0;
}


renderer.domElement.addEventListener('click',onPick);
renderer.domElement.addEventListener('touchend',e=>onPick(e),{passive:true});

// ==================== Camera Info ====================
const camInfo=document.getElementById('camInfo');
function updateCameraInfo(){
  camInfo.innerHTML=`<b>PerspectiveCamera</b><br>
FOV: ${camera.fov.toFixed(2)}<br>
Aspect: ${camera.aspect.toFixed(2)}<br>
Near: ${camera.near}<br>
Far: ${camera.far}<br><br>
<b>Camera Position</b><br>
x: ${camera.position.x.toFixed(2)}<br>
y: ${camera.position.y.toFixed(2)}<br>
z: ${camera.position.z.toFixed(2)}`;
}

// ==================== Animate loop ====================
(function loop(){
  if(riverMesh) riverMesh.material.uniforms.uTime.value = performance.now()/1000*0.5;

  // Lerp camera
  if(targetPos && targetTar && lerpProgress<1){
    lerpProgress+=lerpSpeed;
    if(lerpProgress>1) lerpProgress=1;
    camera.position.lerpVectors(camera.position,targetPos,lerpProgress);
    controls.target.lerpVectors(controls.target,targetTar,lerpProgress);
  }

  controls.update();
  renderer.render(scene,camera);
  updateCameraInfo();
  requestAnimationFrame(loop);
})();

// ==================== Resize ====================
window.addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
