<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <title> FINAL </title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,body { height:100%; margin:0; overflow:hidden; }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
</head>
<body>
<script>
const scene = new THREE.Scene();

// HDR Background
const rgbeLoader = new THREE.RGBELoader();
rgbeLoader.load("https://natthawadee-jansamut.github.io/Model_Final/syferfontein_1d_clear_puresky_1k.hdr", function(texture) {
  texture.mapping = THREE.EquirectangularReflectionMapping;
  scene.background = texture;
  scene.environment = texture;
});

// Camera / Renderer / Controls
const camera = new THREE.PerspectiveCamera(100, innerWidth/innerHeight, 0.1, 200);
camera.position.set(60, 40, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enabled = true;

// Lights
const hemi = new THREE.HemisphereLight(0xffffff, 0x333333, 0.6);
scene.add(hemi);

const dir = new THREE.DirectionalLight(0xffffff, 0.5);
dir.position.set(5, 10, 5);
dir.castShadow = true;
scene.add(dir);

// Environment CubeMap
const cubeUrls = [
  'https://threejs.org/examples/textures/cube/Bridge2/posx.jpg',
  'https://threejs.org/examples/textures/cube/Bridge2/negx.jpg',
  'https://threejs.org/examples/textures/cube/Bridge2/posy.jpg',
  'https://threejs.org/examples/textures/cube/Bridge2/negy.jpg',
  'https://threejs.org/examples/textures/cube/Bridge2/posz.jpg',
  'https://threejs.org/examples/textures/cube/Bridge2/negz.jpg'
];
const envMap = new THREE.CubeTextureLoader().load(cubeUrls);
envMap.encoding = THREE.sRGBEncoding;
scene.environment = envMap;

let mixer = null;
const clickable = [];
let cubeObj = null;
let picObj = null;
let cameraTargetPos = null;
let cameraTargetLook = null;

// GLTF Loader + DRACO
const loader = new THREE.GLTFLoader();
const dracoLoader = new THREE.DRACOLoader();
dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
loader.setDRACOLoader(dracoLoader);

loader.load(
  'https://natthawadee-jansamut.github.io/Model_Final/PORT2.glb',
  (gltf) => {
    const model = gltf.scene || gltf.scenes[0];
    model.traverse((node) => {
      if(node.isMesh){
        node.castShadow = true;
        node.receiveShadow = true;
        if(node.material && (node.material.isMeshStandardMaterial || node.material.isMeshPhysicalMaterial)){
          node.material.envMap = envMap;
          node.material.needsUpdate = true;
        }
        // เก็บ Object สำหรับ Picking
        if(node.name === "Cube") {
          cubeObj = node;
          clickable.push(cubeObj);
        }
        if(node.name === "PIC") {
          picObj = node;
          clickable.push(picObj); // <-- ต้องเพิ่มตรงนี้
          // <-- หมุน PIC 180° ตั้งแต่ต้น
          picObj.rotation.x = Math.PI; // 180° รอบแกน X
        }
      }
    });
    if(gltf.animations && gltf.animations.length){
      mixer = new THREE.AnimationMixer(model);
      gltf.animations.forEach((clip) => mixer.clipAction(clip).play());
    }
    scene.add(model);
  },
  undefined,
  (error) => console.error('Error loading glTF:', error)
);

// Raycaster สำหรับคลิกวัตถุ
const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();

function setPointer(e){
  const r = renderer.domElement.getBoundingClientRect();
  const x = (e.clientX ?? e.touches[0].clientX) - r.left;
  const y = (e.clientY ?? e.touches[0].clientY) - r.top;
  pointer.x = (x / r.width) * 2 - 1;
  pointer.y = -(y / r.height) * 2 + 1;
}

// กล้องเริ่มต้น
const cameraStartPos = camera.position.clone();
const cameraStartLook = new THREE.Vector3(0,0,0);

function onPick(e){
  setPointer(e);
  raycaster.setFromCamera(pointer, camera);
  const hit = raycaster.intersectObjects(clickable, false)[0];
  if(!hit) return;

  // คลิก Cube → กล้องไป PIC
  if(hit.object.name === "Cube" && picObj){
      const offset = new THREE.Vector3(10, 2, 0);
      cameraTargetPos = new THREE.Vector3().copy(picObj.position).add(offset);
      cameraTargetLook = new THREE.Vector3().copy(picObj.position);
  }
  // คลิก PIC → กลับกล้องเริ่มต้น
  if(hit.object.name === "PIC"){
      cameraTargetPos = cameraStartPos.clone();
      cameraTargetLook = cameraStartLook.clone();
  }
}

renderer.domElement.addEventListener('click', onPick);
renderer.domElement.addEventListener('touchend', (e)=>{onPick(e);},{passive:true});

// Resize
window.addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// Animate
const clock = new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const delta = clock.getDelta();
  if(mixer) mixer.update(delta);

  // เลื่อนกล้องแบบ smooth
  if(cameraTargetPos && cameraTargetLook){
    if(cameraTargetPos && cameraTargetLook){
    camera.position.lerp(cameraTargetPos, 0.05);
    controls.target.lerp(cameraTargetLook, 0.05);
    controls.update();
}

  }

  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>


